const { Scenes, Markup } = require('telegraf')
const db = require('../../database/connection')
const crmService = require('../../services/crm')
const novaPoshtaService = require('../../services/novaPoshta')

// Helper function to clear all timeouts
const clearAllTimeouts = (ctx) => {
  if (ctx.scene.state.timeoutId) {
    clearTimeout(ctx.scene.state.timeoutId)
    ctx.scene.state.timeoutId = null
  }
}

// Helper function to set timeout
const setOrderTimeout = (ctx) => {
  // Clear any existing timeout first
  clearAllTimeouts(ctx)

  const timeoutId = setTimeout(() => {
    // Clear the timeout immediately to prevent repeated messages
    clearAllTimeouts(ctx)

    ctx.reply(
      '‚è±Ô∏è –ß–∞—Å –æ—á—ñ–∫—É–≤–∞–Ω–Ω—è –≤–∏—á–µ—Ä–ø–∞–Ω–æ. –ó–∞–º–æ–≤–ª–µ–Ω–Ω—è —Å–∫–∞—Å–æ–≤–∞–Ω–æ.\n\n' +
      '–©–æ–± —Ä–æ–∑–ø–æ—á–∞—Ç–∏ –Ω–æ–≤–µ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è, –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ /start',
      Markup.inlineKeyboard([
        [Markup.button.callback('üè† –ì–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é', 'main_menu')]
      ])
    )
    ctx.scene.leave()
  }, 300000) // 5 minutes

  ctx.scene.state.timeoutId = timeoutId
}

const orderWizard = new Scenes.WizardScene(
  'order-wizard',

  // Step 1: Color selection (if available)
  async(ctx) => {
    setOrderTimeout(ctx)

    const productId = ctx.scene.state.productId
    if (!productId) {
      clearAllTimeouts(ctx)
      await ctx.reply('‚ùå –ü–æ–º–∏–ª–∫–∞: –Ω–µ –≤–∫–∞–∑–∞–Ω–æ —Ç–æ–≤–∞—Ä.')
      return ctx.scene.leave()
    }

    const product = await db.get('SELECT * FROM products WHERE id = ?', [productId])

    if (!product) {
      clearAllTimeouts(ctx)
      await ctx.reply('‚ùå –¢–æ–≤–∞—Ä –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.')
      return ctx.scene.leave()
    }

    ctx.scene.state.product = product

    // Parse product variants
    let variants = { colors: [], sizes: [] }
    try {
      if (product.description) {
        variants = JSON.parse(product.description)
      }
    } catch (e) {
      console.log('Failed to parse product variants')
    }

    ctx.scene.state.availableColors = variants.colors || []
    ctx.scene.state.availableSizes = variants.sizes || []

    // If product has colors, show color selection
    if (ctx.scene.state.availableColors.length > 0) {
      const colorButtons = ctx.scene.state.availableColors.map(color => 
        [Markup.button.callback(color, `color_${color}`)]
      )

      await ctx.reply(
        `üõí –û—Ñ–æ—Ä–º–ª–µ–Ω–Ω—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è\n\nüì¶ –¢–æ–≤–∞—Ä: ${product.name}\nüí∞ –¶—ñ–Ω–∞: ${product.sale_price || product.price}‚Ç¥\n\nüé® –û–±–µ—Ä—ñ—Ç—å –∫–æ–ª—ñ—Ä:`,
        Markup.inlineKeyboard([
          ...colorButtons,
          [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏', 'cancel_order')]
        ])
      )
      return ctx.wizard.next()
    } else {
      // Skip to size selection if no colors
      ctx.scene.state.selectedColor = null
      return ctx.wizard.selectStep(2)
    }
  },

  // Step 2: Size selection (if available)
  async(ctx) => {
    // If we came from a callback query
    if (ctx.callbackQuery) {
      // Handle color selection
      const colorMatch = ctx.callbackQuery.data.match(/^color_(.+)$/)
      if (colorMatch) {
        ctx.scene.state.selectedColor = colorMatch[1]
        await ctx.answerCbQuery()
      }
      
      // Handle size guide
      if (ctx.callbackQuery.data === 'size_guide') {
        await ctx.answerCbQuery()
        const sizeButtons = []
        const sizesPerRow = 3
        
        for (let i = 0; i < ctx.scene.state.availableSizes.length; i += sizesPerRow) {
          const row = ctx.scene.state.availableSizes
            .slice(i, i + sizesPerRow)
            .map(size => Markup.button.callback(size, `size_${size}`))
          sizeButtons.push(row)
        }

        await ctx.editMessageText(
          'üìñ –î–æ–≤—ñ–¥–∫–∞ –ø–æ —Ä–æ–∑–º—ñ—Ä–∞—Ö\n\n' +
          'XS - –æ–±—Ö–≤–∞—Ç –≥—Ä—É–¥–µ–π: 82-86 —Å–º\n' +
          'S - –æ–±—Ö–≤–∞—Ç –≥—Ä—É–¥–µ–π: 86-90 —Å–º\n' +
          'M - –æ–±—Ö–≤–∞—Ç –≥—Ä—É–¥–µ–π: 90-94 —Å–º\n' +
          'L - –æ–±—Ö–≤–∞—Ç –≥—Ä—É–¥–µ–π: 94-98 —Å–º\n' +
          'XL - –æ–±—Ö–≤–∞—Ç –≥—Ä—É–¥–µ–π: 98-102 —Å–º\n' +
          'XXL - –æ–±—Ö–≤–∞—Ç –≥—Ä—É–¥–µ–π: 102-106 —Å–º\n' +
          '3XL - –æ–±—Ö–≤–∞—Ç –≥—Ä—É–¥–µ–π: 106-110 —Å–º\n' +
          '4XL - –æ–±—Ö–≤–∞—Ç –≥—Ä—É–¥–µ–π: 110-114 —Å–º\n' +
          '5XL - –æ–±—Ö–≤–∞—Ç –≥—Ä—É–¥–µ–π: 114-118 —Å–º\n\n' +
          '–û–±–µ—Ä—ñ—Ç—å –≤–∞—à —Ä–æ–∑–º—ñ—Ä:',
          Markup.inlineKeyboard([
            ...sizeButtons,
            [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏', 'cancel_order')]
          ])
        )
        return
      }
    }

    // If product has sizes, show size selection
    if (ctx.scene.state.availableSizes.length > 0) {
      const sizeButtons = []
      const sizesPerRow = 3
      
      for (let i = 0; i < ctx.scene.state.availableSizes.length; i += sizesPerRow) {
        const row = ctx.scene.state.availableSizes
          .slice(i, i + sizesPerRow)
          .map(size => Markup.button.callback(size, `size_${size}`))
        sizeButtons.push(row)
      }

      let message = `üìè –û–±–µ—Ä—ñ—Ç—å —Ä–æ–∑–º—ñ—Ä:`
      if (ctx.scene.state.selectedColor) {
        message = `–ö–æ–ª—ñ—Ä: ${ctx.scene.state.selectedColor}\n\n${message}`
      }

      await ctx.reply(
        message,
        Markup.inlineKeyboard([
          ...sizeButtons,
          [Markup.button.callback('üìñ –î–æ–≤—ñ–¥–∫–∞ –ø–æ —Ä–æ–∑–º—ñ—Ä–∞—Ö', 'size_guide')],
          [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏', 'cancel_order')]
        ])
      )
      return ctx.wizard.next()
    } else {
      // Skip to customer name if no sizes
      ctx.scene.state.selectedSize = null
      return ctx.wizard.selectStep(3)
    }
  },

  // Step 3: Customer first name
  async(ctx) => {
    // If we came from a callback query (size selection)
    if (ctx.callbackQuery) {
      const sizeMatch = ctx.callbackQuery.data.match(/^size_(.+)$/)
      if (sizeMatch) {
        ctx.scene.state.selectedSize = sizeMatch[1]
        await ctx.answerCbQuery()
      }
    }

    setOrderTimeout(ctx)

    let orderDetails = `üõí –í–∞—à–µ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è:\nüì¶ ${ctx.scene.state.product.name}\n`
    if (ctx.scene.state.selectedColor) {
      orderDetails += `üé® –ö–æ–ª—ñ—Ä: ${ctx.scene.state.selectedColor}\n`
    }
    if (ctx.scene.state.selectedSize) {
      orderDetails += `üìè –†–æ–∑–º—ñ—Ä: ${ctx.scene.state.selectedSize}\n`
    }
    orderDetails += `üí∞ –¶—ñ–Ω–∞: ${ctx.scene.state.product.sale_price || ctx.scene.state.product.price}‚Ç¥\n\n`

    await ctx.reply(
      orderDetails + 'üë§ –í–≤–µ–¥—ñ—Ç—å –≤–∞—à–µ —ñ–º\'—è:',
      Markup.inlineKeyboard([
        [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏', 'cancel_order')]
      ])
    )

    return ctx.wizard.next()
  },

  // Step 4: Customer last name
  async(ctx) => {
    // Reset timeout on user activity
    setOrderTimeout(ctx)

    if (!ctx.message?.text) {
      await ctx.reply('‚ùå –ë—É–¥—å –ª–∞—Å–∫–∞, –≤–≤–µ–¥—ñ—Ç—å –≤–∞—à–µ —ñ–º\'—è —Ç–µ–∫—Å—Ç–æ–º.')
      return
    }

    ctx.scene.state.customerFirstName = ctx.message.text.trim()

    await ctx.reply(
      'üë§ –í–≤–µ–¥—ñ—Ç—å –≤–∞—à–µ –ø—Ä—ñ–∑–≤–∏—â–µ:',
      Markup.inlineKeyboard([
        [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏', 'cancel_order')]
      ])
    )

    return ctx.wizard.next()
  },

  // Step 5: Phone number
  async(ctx) => {
    // Reset timeout on user activity
    setOrderTimeout(ctx)

    if (!ctx.message?.text) {
      await ctx.reply('‚ùå –ë—É–¥—å –ª–∞—Å–∫–∞, –≤–≤–µ–¥—ñ—Ç—å –≤–∞—à–µ –ø—Ä—ñ–∑–≤–∏—â–µ —Ç–µ–∫—Å—Ç–æ–º.')
      return
    }

    ctx.scene.state.customerLastName = ctx.message.text.trim()
    ctx.scene.state.customerName = `${ctx.scene.state.customerFirstName} ${ctx.scene.state.customerLastName}`

    await ctx.reply(
      'üì± –í–≤–µ–¥—ñ—Ç—å –≤–∞—à –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É:\n(–Ω–∞–ø—Ä–∏–∫–ª–∞–¥: +380501234567)',
      Markup.inlineKeyboard([
        [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏', 'cancel_order')]
      ])
    )

    return ctx.wizard.next()
  },

  // Step 6: Delivery method (Nova Poshta city)
  async(ctx) => {
    // Reset timeout on user activity
    setOrderTimeout(ctx)

    if (!ctx.message?.text) {
      await ctx.reply('‚ùå –ë—É–¥—å –ª–∞—Å–∫–∞, –≤–≤–µ–¥—ñ—Ç—å –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É.')
      return
    }

    const phone = ctx.message.text.trim()
    if (!/^\+?3?8?0\d{9}$/.test(phone.replace(/[-\s()]/g, ''))) {
      await ctx.reply('‚ùå –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∏–π —Ñ–æ—Ä–º–∞—Ç —Ç–µ–ª–µ—Ñ–æ–Ω—É. –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑:\n(–Ω–∞–ø—Ä–∏–∫–ª–∞–¥: +380501234567)')
      return
    }

    ctx.scene.state.customerPhone = phone

    await ctx.reply(
      'üì¶ –î–æ—Å—Ç–∞–≤–∫–∞ —á–µ—Ä–µ–∑ –ù–æ–≤–∞ –ü–æ—à—Ç–∞\n\n–í–≤–µ–¥—ñ—Ç—å –Ω–∞–∑–≤—É –≤–∞—à–æ–≥–æ –º—ñ—Å—Ç–∞:',
      Markup.inlineKeyboard([
        [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏', 'cancel_order')]
      ])
    )

    // Set delivery method and city input mode directly
    ctx.scene.state.deliveryMethod = '–ù–æ–≤–∞ –ü–æ—à—Ç–∞'
    ctx.scene.state.waitingForCity = true

    return ctx.wizard.next()
  },

  // Step 7: Handle Nova Poshta city search and warehouse selection
  async(ctx) => {
    if (ctx.message || ctx.callbackQuery) {
      setOrderTimeout(ctx)
    }

    // Handle change city request in step 7
    if (ctx.callbackQuery?.data === 'change_city') {
      await ctx.answerCbQuery()
      ctx.scene.state.waitingForCity = true
      ctx.scene.state.selectedCity = null
      ctx.scene.state.availableWarehouses = null
      ctx.scene.state.selectedWarehouse = null

      await ctx.editMessageText(
        'üèôÔ∏è –í–≤–µ–¥—ñ—Ç—å –Ω–∞–∑–≤—É –≤–∞—à–æ–≥–æ –º—ñ—Å—Ç–∞ –¥–ª—è –¥–æ—Å—Ç–∞–≤–∫–∏ –ù–æ–≤–∞ –ü–æ—à—Ç–∞:\n\n' +
        'üí° –ü—ñ–¥–∫–∞–∑–∫–∞: –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ —É–∫—Ä–∞—ó–Ω—Å—å–∫—É –º–æ–≤—É\n' +
        '–ù–∞–ø—Ä–∏–∫–ª–∞–¥: –ö–∏—ó–≤, –•–∞—Ä–∫—ñ–≤, –õ—å–≤—ñ–≤, –û–¥–µ—Å–∞',
        Markup.inlineKeyboard([
          [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏', 'cancel_order')]
        ])
      )
      return
    }

    // Handle city input for Nova Poshta
    if (ctx.scene.state.waitingForCity && ctx.message?.text) {
      const cityName = ctx.message.text.trim()
      await ctx.reply('üîç –®—É–∫–∞—î–º–æ –≤–∞—à–µ –º—ñ—Å—Ç–æ...')

      try {
        const cities = await novaPoshtaService.searchCities(cityName)

        if (cities.length === 0) {
          await ctx.reply(
            `‚ùå –ú—ñ—Å—Ç–æ "${cityName}" –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.\n\n` +
            'üí° –ü—ñ–¥–∫–∞–∑–∫–∞: –í–≤–µ–¥—ñ—Ç—å –Ω–∞–∑–≤—É –º—ñ—Å—Ç–∞ —É–∫—Ä–∞—ó–Ω—Å—å–∫–æ—é –º–æ–≤–æ—é.\n' +
            '–ù–∞–ø—Ä–∏–∫–ª–∞–¥: –ö–∏—ó–≤, –•–∞—Ä–∫—ñ–≤, –õ—å–≤—ñ–≤, –û–¥–µ—Å–∞\n\n' +
            '–°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑:',
            Markup.inlineKeyboard([
              [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è', 'cancel_order')]
            ])
          )
          // Stay in the same step to allow retry
          return
        }

        if (cities.length === 1) {
          // Only one city found, ask for manual branch input
          ctx.scene.state.selectedCity = cities[0]
          ctx.scene.state.waitingForCity = false
          ctx.scene.state.waitingForWarehouseNumber = true

          await ctx.reply(
            `üì¶ –ú—ñ—Å—Ç–æ ${cities[0].name} –æ–±—Ä–∞–Ω–æ.\n\n` +
            '‚úçÔ∏è –í–≤–µ–¥—ñ—Ç—å –Ω–æ–º–µ—Ä –≤—ñ–¥–¥—ñ–ª–µ–Ω–Ω—è –∞–±–æ –ø–æ—à—Ç–æ–º–∞—Ç—É –ù–æ–≤–∞ –ü–æ—à—Ç–∞:\n\n' +
            'üí° –ü—Ä–∏–∫–ª–∞–¥–∏:\n' +
            '‚Ä¢ –î–ª—è –≤—ñ–¥–¥—ñ–ª–µ–Ω–Ω—è: 1, 2, 142\n' +
            '‚Ä¢ –î–ª—è –ø–æ—à—Ç–æ–º–∞—Ç—É: 5310, 26571\n\n' +
            '‚ÑπÔ∏è –í–∏ –º–æ–∂–µ—Ç–µ –∑–Ω–∞–π—Ç–∏ –Ω–æ–º–µ—Ä –Ω–∞ —Å–∞–π—Ç—ñ –ù–æ–≤–∞ –ü–æ—à—Ç–∞ –∞–±–æ —É –¥–æ–¥–∞—Ç–∫—É',
            Markup.inlineKeyboard([
              [Markup.button.callback('‚¨Ö –ó–º—ñ–Ω–∏—Ç–∏ –º—ñ—Å—Ç–æ', 'change_city')],
              [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è', 'cancel_order')]
            ])
          )

          return ctx.wizard.next()
        } else {
          // Multiple cities found, show selection
          ctx.scene.state.availableCities = cities

          await ctx.reply(
            'üèôÔ∏è –ó–Ω–∞–π–¥–µ–Ω–æ –∫—ñ–ª—å–∫–∞ –º—ñ—Å—Ç –∑ —Ç–∞–∫–æ—é –Ω–∞–∑–≤–æ—é. –û–±–µ—Ä—ñ—Ç—å –ø–æ—Ç—Ä—ñ–±–Ω–µ:',
            novaPoshtaService.formatCitiesForKeyboard(cities)
          )
          return
        }
      } catch (error) {
        console.error('Nova Poshta search error:', error)
        await ctx.reply(
          '‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –ø–æ—à—É–∫—É –º—ñ—Å—Ç–∞. –ú–æ–∂–ª–∏–≤—ñ –ø—Ä–∏—á–∏–Ω–∏:\n\n' +
          '‚Ä¢ –ü—Ä–æ–±–ª–µ–º–∏ –∑ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è–º –¥–æ –ù–æ–≤–æ—ó –ü–æ—à—Ç–∏\n' +
          '‚Ä¢ –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ –≤–≤–µ–¥–µ–Ω–∞ –Ω–∞–∑–≤–∞ –º—ñ—Å—Ç–∞\n\n' +
          '–°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑ –∞–±–æ –∑–≤–µ—Ä–Ω—ñ—Ç—å—Å—è –¥–æ –ø—ñ–¥—Ç—Ä–∏–º–∫–∏.',
          Markup.inlineKeyboard([
            [Markup.button.callback('üîÑ –°–ø—Ä–æ–±—É–≤–∞—Ç–∏ —â–µ —Ä–∞–∑', 'retry_city')],
            [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è', 'cancel_order')]
          ])
        )
        return
      }
    }

    // Handle city selection from multiple options
    if (ctx.callbackQuery?.data?.startsWith('city_')) {
      const cityRef = ctx.callbackQuery.data.replace('city_', '')
      const selectedCity = ctx.scene.state.availableCities?.find(city => city.ref === cityRef)

      if (!selectedCity) {
        await ctx.answerCbQuery('‚ùå –ü–æ–º–∏–ª–∫–∞ –≤–∏–±–æ—Ä—É –º—ñ—Å—Ç–∞')
        return
      }

      ctx.scene.state.selectedCity = selectedCity
      ctx.scene.state.waitingForCity = false
      await ctx.answerCbQuery()

      ctx.scene.state.waitingForWarehouseNumber = true
      
      await ctx.editMessageText(
        `üì¶ –ú—ñ—Å—Ç–æ ${selectedCity.name} –æ–±—Ä–∞–Ω–æ.\n\n` +
        '‚úçÔ∏è –í–≤–µ–¥—ñ—Ç—å –Ω–æ–º–µ—Ä –≤—ñ–¥–¥—ñ–ª–µ–Ω–Ω—è –∞–±–æ –ø–æ—à—Ç–æ–º–∞—Ç—É –ù–æ–≤–∞ –ü–æ—à—Ç–∞:\n\n' +
        'üí° –ü—Ä–∏–∫–ª–∞–¥–∏:\n' +
        '‚Ä¢ –î–ª—è –≤—ñ–¥–¥—ñ–ª–µ–Ω–Ω—è: 1, 2, 142\n' +
        '‚Ä¢ –î–ª—è –ø–æ—à—Ç–æ–º–∞—Ç—É: 5310, 26571\n\n' +
        '‚ÑπÔ∏è –í–∏ –º–æ–∂–µ—Ç–µ –∑–Ω–∞–π—Ç–∏ –Ω–æ–º–µ—Ä –Ω–∞ —Å–∞–π—Ç—ñ –ù–æ–≤–∞ –ü–æ—à—Ç–∞ –∞–±–æ —É –¥–æ–¥–∞—Ç–∫—É',
        Markup.inlineKeyboard([
          [Markup.button.callback('‚¨Ö –ó–º—ñ–Ω–∏—Ç–∏ –º—ñ—Å—Ç–æ', 'change_city')],
          [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è', 'cancel_order')]
        ])
      )

      return ctx.wizard.next()
    }

    // Handle unexpected input or stuck state
    if (!ctx.callbackQuery && !ctx.scene.state.waitingForCity) {
      await ctx.reply(
        '‚ö†Ô∏è –©–æ—Å—å –ø—ñ—à–ª–æ –Ω–µ —Ç–∞–∫. –ë—É–¥—å –ª–∞—Å–∫–∞, –≤–≤–µ–¥—ñ—Ç—å –Ω–∞–∑–≤—É –≤–∞—à–æ–≥–æ –º—ñ—Å—Ç–∞ –¥–ª—è –¥–æ—Å—Ç–∞–≤–∫–∏:',
        Markup.inlineKeyboard([
          [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è', 'cancel_order')]
        ])
      )
      ctx.scene.state.waitingForCity = true
      return
    }

    // If still waiting for city but no valid input
    if (ctx.scene.state.waitingForCity) {
      await ctx.reply(
        '‚ùå –ë—É–¥—å –ª–∞—Å–∫–∞, –≤–≤–µ–¥—ñ—Ç—å –Ω–∞–∑–≤—É –º—ñ—Å—Ç–∞ —Ç–µ–∫—Å—Ç–æ–º.\n' +
        '–ù–∞–ø—Ä–∏–∫–ª–∞–¥: –ö–∏—ó–≤, –•–∞—Ä–∫—ñ–≤, –õ—å–≤—ñ–≤',
        Markup.inlineKeyboard([
          [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è', 'cancel_order')]
        ])
      )
    }
  },

  // Step 8: Handle warehouse selection and payment method
  async(ctx) => {
    // Reset timeout on user activity
    if (ctx.callbackQuery || ctx.message) {
      setOrderTimeout(ctx)
    }

    // Handle change city request
    if (ctx.callbackQuery?.data === 'change_city') {
      await ctx.answerCbQuery()
      ctx.scene.state.waitingForCity = true
      ctx.scene.state.selectedCity = null
      ctx.scene.state.availableWarehouses = null
      ctx.scene.state.selectedWarehouse = null

      await ctx.editMessageText(
        'üèôÔ∏è –í–≤–µ–¥—ñ—Ç—å –Ω–∞–∑–≤—É –≤–∞—à–æ–≥–æ –º—ñ—Å—Ç–∞ –¥–ª—è –¥–æ—Å—Ç–∞–≤–∫–∏ –ù–æ–≤–∞ –ü–æ—à—Ç–∞:\n\n' +
        'üí° –ü—ñ–¥–∫–∞–∑–∫–∞: –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ —É–∫—Ä–∞—ó–Ω—Å—å–∫—É –º–æ–≤—É\n' +
        '–ù–∞–ø—Ä–∏–∫–ª–∞–¥: –ö–∏—ó–≤, –•–∞—Ä–∫—ñ–≤, –õ—å–≤—ñ–≤, –û–¥–µ—Å–∞',
        Markup.inlineKeyboard([
          [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏', 'cancel_order')]
        ])
      )

      return ctx.wizard.selectStep(6) // Go back to step 7 (city selection)
    }

    // Handle manual warehouse number input
    if (ctx.scene.state.waitingForWarehouseNumber && ctx.message?.text) {
      const warehouseNumber = ctx.message.text.trim()
      
      // Validate warehouse number format (1-5 digits)
      if (!/^\d{1,5}$/.test(warehouseNumber)) {
        await ctx.reply(
          '‚ùå –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∏–π —Ñ–æ—Ä–º–∞—Ç –Ω–æ–º–µ—Ä–∞.\n\n' +
          '–ù–æ–º–µ—Ä –º–∞—î —Å–∫–ª–∞–¥–∞—Ç–∏—Å—è —Ç—ñ–ª—å–∫–∏ –∑ —Ü–∏—Ñ—Ä (1-5 –∑–Ω–∞–∫—ñ–≤).\n' +
          '–ü—Ä–∏–∫–ª–∞–¥–∏: 1, 142, 5310\n\n' +
          '–°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑:',
          Markup.inlineKeyboard([
            [Markup.button.callback('‚¨Ö –ó–º—ñ–Ω–∏—Ç–∏ –º—ñ—Å—Ç–æ', 'change_city')],
            [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è', 'cancel_order')]
          ])
        )
        return
      }

      await ctx.reply('üîç –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –≤—ñ–¥–¥—ñ–ª–µ–Ω–Ω—è...')

      try {
        // Validate warehouse exists in the selected city
        const warehouses = await novaPoshtaService.getWarehouses(ctx.scene.state.selectedCity.ref)
        const validWarehouse = warehouses.find(wh => wh.number === warehouseNumber)

        if (!validWarehouse) {
          await ctx.reply(
            `‚ùå –í—ñ–¥–¥—ñ–ª–µ–Ω–Ω—è ‚Ññ${warehouseNumber} –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ –≤ –º—ñ—Å—Ç—ñ ${ctx.scene.state.selectedCity.name}.\n\n` +
            'üí° –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –Ω–æ–º–µ—Ä –Ω–∞ —Å–∞–π—Ç—ñ –ù–æ–≤–∞ –ü–æ—à—Ç–∞ –∞–±–æ –≤ –¥–æ–¥–∞—Ç–∫—É.\n\n' +
            '–°–ø—Ä–æ–±—É–π—Ç–µ —ñ–Ω—à–∏–π –Ω–æ–º–µ—Ä:',
            Markup.inlineKeyboard([
              [Markup.button.callback('‚¨Ö –ó–º—ñ–Ω–∏—Ç–∏ –º—ñ—Å—Ç–æ', 'change_city')],
              [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è', 'cancel_order')]
            ])
          )
          return
        }

        // Warehouse found and validated
        ctx.scene.state.selectedWarehouse = validWarehouse
        ctx.scene.state.waitingForWarehouseNumber = false

        await ctx.reply(
          `‚úÖ –í—ñ–¥–¥—ñ–ª–µ–Ω–Ω—è –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–æ:\n` +
          `üì¶ ‚Ññ${validWarehouse.number} - ${validWarehouse.description}\n\n` +
          'üí≥ –û–±–µ—Ä—ñ—Ç—å —Å–ø–æ—Å—ñ–± –æ–ø–ª–∞—Ç–∏:',
          Markup.inlineKeyboard([
            [Markup.button.callback('üìÆ –ü—ñ—Å–ª—è–ø–ª–∞—Ç–∞', 'payment_postpaid')],
            [Markup.button.callback('üí≥ –ü–µ—Ä–µ–¥–æ–ø–ª–∞—Ç–∞ –Ω–∞ –∫–∞—Ä—Ç—É', 'payment_prepaid')],
            [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏', 'cancel_order')]
          ])
        )

        return ctx.wizard.next()
      } catch (error) {
        console.error('Warehouse validation error:', error)
        await ctx.reply(
          '‚ùå –ü–æ–º–∏–ª–∫–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ –≤—ñ–¥–¥—ñ–ª–µ–Ω–Ω—è.\n\n' +
          '–°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑ –∞–±–æ –∑–≤–µ—Ä–Ω—ñ—Ç—å—Å—è –¥–æ –ø—ñ–¥—Ç—Ä–∏–º–∫–∏:',
          Markup.inlineKeyboard([
            [Markup.button.callback('‚¨Ö –ó–º—ñ–Ω–∏—Ç–∏ –º—ñ—Å—Ç–æ', 'change_city')],
            [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è', 'cancel_order')]
          ])
        )
        return
      }
    }

    // Handle invalid input when waiting for warehouse number
    if (ctx.scene.state.waitingForWarehouseNumber && !ctx.message?.text) {
      await ctx.reply(
        '‚ùå –ë—É–¥—å –ª–∞—Å–∫–∞, –≤–≤–µ–¥—ñ—Ç—å –Ω–æ–º–µ—Ä –≤—ñ–¥–¥—ñ–ª–µ–Ω–Ω—è —Ç–µ–∫—Å—Ç–æ–º.\n' +
        '–ü—Ä–∏–∫–ª–∞–¥–∏: 1, 142, 5310',
        Markup.inlineKeyboard([
          [Markup.button.callback('‚¨Ö –ó–º—ñ–Ω–∏—Ç–∏ –º—ñ—Å—Ç–æ', 'change_city')],
          [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è', 'cancel_order')]
        ])
      )
    }
  },

  // Step 9: Order confirmation
  async(ctx) => {
    // Reset timeout on user activity
    if (ctx.callbackQuery) {
      setOrderTimeout(ctx)
    }

    const paymentMethods = {
      payment_postpaid: '–ü—ñ—Å–ª—è–ø–ª–∞—Ç–∞',
      payment_prepaid: '–ü–µ—Ä–µ–¥–æ–ø–ª–∞—Ç–∞ –Ω–∞ –∫–∞—Ä—Ç—É'
    }

    if (!ctx.callbackQuery || !paymentMethods[ctx.callbackQuery.data]) {
      await ctx.reply('‚ùå –ë—É–¥—å –ª–∞—Å–∫–∞, –æ–±–µ—Ä—ñ—Ç—å —Å–ø–æ—Å—ñ–± –æ–ø–ª–∞—Ç–∏ –∑ –∫–Ω–æ–ø–æ–∫.')
      return
    }

    ctx.scene.state.paymentMethod = paymentMethods[ctx.callbackQuery.data]
    await ctx.answerCbQuery()

    const { product, customerFirstName, customerLastName, customerPhone, selectedColor, selectedSize, deliveryMethod, paymentMethod } = ctx.scene.state
    const totalAmount = product.sale_price || product.price

    // Build delivery info for Nova Poshta
    let deliveryInfo = ''
    if (ctx.scene.state.selectedCity && ctx.scene.state.selectedWarehouse) {
      deliveryInfo = `üöö –î–æ—Å—Ç–∞–≤–∫–∞: ${deliveryMethod}\n` +
        `üèôÔ∏è –ú—ñ—Å—Ç–æ: ${ctx.scene.state.selectedCity.name} (${ctx.scene.state.selectedCity.area})\n` +
        `üì¶ –í—ñ–¥–¥—ñ–ª–µ–Ω–Ω—è: ‚Ññ${ctx.scene.state.selectedWarehouse.number} - ${ctx.scene.state.selectedWarehouse.description.substring(0, 50)}...\n`
    }

    const orderSummary = 'üìã –ü—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è\n\n' +
      `üë§ –Ü–º'—è: ${customerFirstName}\n` +
      `üë§ –ü—Ä—ñ–∑–≤–∏—â–µ: ${customerLastName}\n` +
      `üì± –¢–µ–ª–µ—Ñ–æ–Ω: ${customerPhone}\n` +
      `üì¶ –¢–æ–≤–∞—Ä: ${product.name}\n` +
      (selectedColor ? `üé® –ö–æ–ª—ñ—Ä: ${selectedColor}\n` : '') +
      (selectedSize ? `üìè –†–æ–∑–º—ñ—Ä: ${selectedSize}\n` : '') +
      `üí∞ –¶—ñ–Ω–∞: ${totalAmount}‚Ç¥\n` +
      deliveryInfo +
      `üí≥ –û–ø–ª–∞—Ç–∞: ${paymentMethod}\n\n` +
      '‚úÖ –ü—ñ–¥—Ç–≤–µ—Ä–¥–∏—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è?'

    await ctx.editMessageText(
      orderSummary,
      Markup.inlineKeyboard([
        [Markup.button.callback('‚úÖ –ü—ñ–¥—Ç–≤–µ—Ä–¥–∏—Ç–∏', 'confirm_order')],
        [Markup.button.callback('‚úèÔ∏è –†–µ–¥–∞–≥—É–≤–∞—Ç–∏', 'edit_order')],
        [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏', 'cancel_order')]
      ])
    )

    return ctx.wizard.next()
  },

  // Step 10: Submit to CRM
  async(ctx) => {
    if (!ctx.callbackQuery) return

    await ctx.answerCbQuery()

    if (ctx.callbackQuery.data === 'edit_order') {
      setOrderTimeout(ctx) // Reset timeout when editing
      return ctx.wizard.selectStep(0) // Start over
    }

    if (ctx.callbackQuery.data === 'cancel_order') {
      clearAllTimeouts(ctx)
      await ctx.editMessageText('‚ùå –ó–∞–º–æ–≤–ª–µ–Ω–Ω—è —Å–∫–∞—Å–æ–≤–∞–Ω–æ.')
      return ctx.scene.leave()
    }

    if (ctx.callbackQuery.data === 'confirm_order') {
      // Clear timeout when confirming order
      clearAllTimeouts(ctx)
      await ctx.editMessageText('‚è≥ –û–±—Ä–æ–±–ª—è—î–º–æ –≤–∞—à–µ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è...')

      try {
        const { product, customerName, customerFirstName, customerLastName, customerPhone, deliveryMethod, paymentMethod } = ctx.scene.state

        // Get user ID (fallback if ctx.user is not set)
        let userId = ctx.user?.id
        if (!userId) {
          const user = await db.get('SELECT id FROM users WHERE telegram_id = ?', [ctx.from.id])
          userId = user?.id
        }

        if (!userId) {
          throw new Error('User not found in database')
        }

        // Build delivery address and Nova Poshta data (Nova Poshta only)
        let deliveryAddress = ''
        let novaPoshta = {}

        if (ctx.scene.state.selectedCity && ctx.scene.state.selectedWarehouse) {
          // Prepare Nova Poshta data for CRM
          novaPoshta = novaPoshtaService.prepareForCRM(ctx.scene.state.selectedCity, ctx.scene.state.selectedWarehouse)
          deliveryAddress = `${ctx.scene.state.selectedCity.name}, –≤—ñ–¥–¥—ñ–ª–µ–Ω–Ω—è ‚Ññ${ctx.scene.state.selectedWarehouse.number}`
          
          // Add postpaid field based on payment method
          if (paymentMethod === '–ü—ñ—Å–ª—è–ø–ª–∞—Ç–∞') {
            novaPoshta.postpaid = 'Payment control'
          } else if (paymentMethod === '–ü–µ—Ä–µ–¥–æ–ø–ª–∞—Ç–∞ –Ω–∞ –∫–∞—Ä—Ç—É') {
            novaPoshta.postpaid = 'No cash on delivery'
          }
        }

        // Build clean product name with selected variants (no JSON data)
        let productDisplayName = product.name
        
        // Remove any JSON data that might be in the product name
        if (productDisplayName.includes('({"colors"')) {
          productDisplayName = productDisplayName.split('({"colors"')[0].trim()
        }
        
        // Add selected variants
        const variants = []
        if (ctx.scene.state.selectedColor) {
          variants.push(ctx.scene.state.selectedColor)
        }
        if (ctx.scene.state.selectedSize) {
          variants.push(ctx.scene.state.selectedSize)
        }
        if (variants.length > 0) {
          productDisplayName += ` - ${variants.join(', ')}`
        }

        // Submit to CRM with Nova Poshta data  
        const crmResult = await crmService.createOrder({
          telegramOrderId: ctx.from.id.toString(), // Use Telegram user ID instead
          products: [{
            id: product.id,
            name: productDisplayName,
            price: product.sale_price || product.price,
            quantity: 1,
            description: '', // Clean description, no JSON data
            color: ctx.scene.state.selectedColor,
            size: ctx.scene.state.selectedSize
          }],
          customerName,
          customerFirstName,
          customerLastName,
          customerPhone,
          telegramUsername: ctx.from.username,
          deliveryMethod,
          deliveryAddress,
          paymentMethod,
          novaPoshta, // Include Nova Poshta parameters
          notes: `The order from the telegram bot. ${ctx.scene.state.selectedColor ? `–ö–æ–ª—ñ—Ä: ${ctx.scene.state.selectedColor}. ` : ''}${ctx.scene.state.selectedSize ? `–†–æ–∑–º—ñ—Ä: ${ctx.scene.state.selectedSize}` : ''}`
        })

        if (crmResult.success) {
          // Clear timeout on successful order
          clearAllTimeouts(ctx)

          await ctx.editMessageText(
            '‚úÖ –ó–∞–º–æ–≤–ª–µ–Ω–Ω—è —É—Å–ø—ñ—à–Ω–æ –æ—Ñ–æ—Ä–º–ª–µ–Ω–æ!\n\n' +
            `üìã –ù–æ–º–µ—Ä –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è: ${crmResult.orderId}\n` +
            'üì± –ù–∞—à –º–µ–Ω–µ–¥–∂–µ—Ä –∑–≤\'—è–∂–µ—Ç—å—Å—è –∑ –≤–∞–º–∏ –Ω–∞–π–±–ª–∏–∂—á–∏–º —á–∞—Å–æ–º.\n\n' +
            '–î—è–∫—É—î–º–æ –∑–∞ –ø–æ–∫—É–ø–∫—É! üôè',
            Markup.inlineKeyboard([
              [Markup.button.callback('üè† –ì–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é', 'main_menu')]
            ])
          )
        } else {
          throw new Error(crmResult.error)
        }
      } catch (error) {
        console.error('Order submission error:', error)
        // Clear timeout on error
        clearAllTimeouts(ctx)

        await ctx.editMessageText(
          '‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ—Ñ–æ—Ä–º–ª–µ–Ω–Ω—ñ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è.\n\n' +
          '–í–∞—à—ñ –¥–∞–Ω—ñ –∑–±–µ—Ä–µ–∂–µ–Ω–æ, –º–∏ –∑–≤\'—è–∂–µ–º–æ—Å—è –∑ –≤–∞–º–∏ –≤—Ä—É—á–Ω—É.\n\n' +
          '–í–∏–±–∞—á—Ç–µ –∑–∞ –Ω–µ–∑—Ä—É—á–Ω–æ—Å—Ç—ñ.',
          Markup.inlineKeyboard([
            [Markup.button.callback('üè† –ì–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é', 'main_menu')]
          ])
        )
      }

      return ctx.scene.leave()
    }
  }
)

// Handle cancel order
orderWizard.action('cancel_order', async(ctx) => {
  await ctx.answerCbQuery()
  clearAllTimeouts(ctx)
  await ctx.editMessageText('‚ùå –ó–∞–º–æ–≤–ª–µ–Ω–Ω—è —Å–∫–∞—Å–æ–≤–∞–Ω–æ.')
  return ctx.scene.leave()
})

// Handle retry city search
orderWizard.action('retry_city', async(ctx) => {
  await ctx.answerCbQuery()
  setOrderTimeout(ctx) // Reset timeout on retry
  ctx.scene.state.waitingForCity = true
  await ctx.editMessageText(
    'üèôÔ∏è –í–≤–µ–¥—ñ—Ç—å –Ω–∞–∑–≤—É –≤–∞—à–æ–≥–æ –º—ñ—Å—Ç–∞ –¥–ª—è –¥–æ—Å—Ç–∞–≤–∫–∏ –ù–æ–≤–∞ –ü–æ—à—Ç–∞:\n\n' +
    'üí° –ü—ñ–¥–∫–∞–∑–∫–∞: –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ —É–∫—Ä–∞—ó–Ω—Å—å–∫—É –º–æ–≤—É\n' +
    '–ù–∞–ø—Ä–∏–∫–ª–∞–¥: –ö–∏—ó–≤, –•–∞—Ä–∫—ñ–≤, –õ—å–≤—ñ–≤, –û–¥–µ—Å–∞',
    Markup.inlineKeyboard([
      [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è', 'cancel_order')]
    ])
  )
})

// Clear timeout on scene leave
orderWizard.leave((ctx) => {
  clearAllTimeouts(ctx)
})

module.exports = orderWizard
