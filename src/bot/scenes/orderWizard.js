const { Scenes, Markup } = require('telegraf')
const db = require('../../database/connection')
const crmService = require('../../services/crm')
const novaPoshtaService = require('../../services/novaPoshta')

// Helper function to clear all timeouts
const clearAllTimeouts = (ctx) => {
  if (ctx.scene.state.timeoutId) {
    clearTimeout(ctx.scene.state.timeoutId)
    ctx.scene.state.timeoutId = null
  }
}

// Helper function to set timeout
const setOrderTimeout = (ctx) => {
  // Clear any existing timeout first
  clearAllTimeouts(ctx)

  const timeoutId = setTimeout(() => {
    // Clear the timeout immediately to prevent repeated messages
    clearAllTimeouts(ctx)

    ctx.reply(
      '‚è±Ô∏è –ß–∞—Å –æ—á—ñ–∫—É–≤–∞–Ω–Ω—è –≤–∏—á–µ—Ä–ø–∞–Ω–æ. –ó–∞–º–æ–≤–ª–µ–Ω–Ω—è —Å–∫–∞—Å–æ–≤–∞–Ω–æ.\n\n' +
      '–©–æ–± —Ä–æ–∑–ø–æ—á–∞—Ç–∏ –Ω–æ–≤–µ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è, –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ /start',
      Markup.inlineKeyboard([
        [Markup.button.callback('üè† –ì–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é', 'main_menu')]
      ])
    )
    ctx.scene.leave()
  }, 300000) // 5 minutes

  ctx.scene.state.timeoutId = timeoutId
}

const orderWizard = new Scenes.WizardScene(
  'order-wizard',

  // Step 1: Customer first name
  async(ctx) => {
    setOrderTimeout(ctx)

    const productId = ctx.scene.state.productId
    if (!productId) {
      clearAllTimeouts(ctx)
      await ctx.reply('‚ùå –ü–æ–º–∏–ª–∫–∞: –Ω–µ –≤–∫–∞–∑–∞–Ω–æ —Ç–æ–≤–∞—Ä.')
      return ctx.scene.leave()
    }

    const product = await db.get('SELECT * FROM products WHERE id = ?', [productId])

    if (!product) {
      clearAllTimeouts(ctx)
      await ctx.reply('‚ùå –¢–æ–≤–∞—Ä –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.')
      return ctx.scene.leave()
    }

    ctx.scene.state.product = product

    await ctx.reply(
      `üõí –û—Ñ–æ—Ä–º–ª–µ–Ω–Ω—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è\n\nüì¶ –¢–æ–≤–∞—Ä: ${product.name}\nüí∞ –¶—ñ–Ω–∞: ${product.sale_price || product.price}‚Ç¥\n\nüë§ –í–≤–µ–¥—ñ—Ç—å –≤–∞—à–µ —ñ–º'—è (–Ü–º'—è):`,
      Markup.inlineKeyboard([
        [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏', 'cancel_order')]
      ])
    )

    return ctx.wizard.next()
  },

  // Step 2: Customer last name
  async(ctx) => {
    // Reset timeout on user activity
    setOrderTimeout(ctx)

    if (!ctx.message?.text) {
      await ctx.reply('‚ùå –ë—É–¥—å –ª–∞—Å–∫–∞, –≤–≤–µ–¥—ñ—Ç—å –≤–∞—à–µ —ñ–º\'—è —Ç–µ–∫—Å—Ç–æ–º.')
      return
    }

    ctx.scene.state.customerFirstName = ctx.message.text.trim()

    await ctx.reply(
      'üë§ –í–≤–µ–¥—ñ—Ç—å –≤–∞—à–µ –ø—Ä—ñ–∑–≤–∏—â–µ (–ü—Ä—ñ–∑–≤–∏—â–µ):',
      Markup.inlineKeyboard([
        [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏', 'cancel_order')]
      ])
    )

    return ctx.wizard.next()
  },

  // Step 3: Phone number
  async(ctx) => {
    // Reset timeout on user activity
    setOrderTimeout(ctx)

    if (!ctx.message?.text) {
      await ctx.reply('‚ùå –ë—É–¥—å –ª–∞—Å–∫–∞, –≤–≤–µ–¥—ñ—Ç—å –≤–∞—à–µ –ø—Ä—ñ–∑–≤–∏—â–µ —Ç–µ–∫—Å—Ç–æ–º.')
      return
    }

    ctx.scene.state.customerLastName = ctx.message.text.trim()
    ctx.scene.state.customerName = `${ctx.scene.state.customerFirstName} ${ctx.scene.state.customerLastName}`

    await ctx.reply(
      'üì± –í–≤–µ–¥—ñ—Ç—å –≤–∞—à –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É:\n(–Ω–∞–ø—Ä–∏–∫–ª–∞–¥: +380501234567)',
      Markup.inlineKeyboard([
        [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏', 'cancel_order')]
      ])
    )

    return ctx.wizard.next()
  },

  // Step 4: Size selection
  async(ctx) => {
    // Reset timeout on user activity
    setOrderTimeout(ctx)

    if (!ctx.message?.text) {
      await ctx.reply('‚ùå –ë—É–¥—å –ª–∞—Å–∫–∞, –≤–≤–µ–¥—ñ—Ç—å –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É.')
      return
    }

    const phone = ctx.message.text.trim()
    if (!/^\+?3?8?0\d{9}$/.test(phone.replace(/[-\s()]/g, ''))) {
      await ctx.reply('‚ùå –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∏–π —Ñ–æ—Ä–º–∞—Ç —Ç–µ–ª–µ—Ñ–æ–Ω—É. –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑:\n(–Ω–∞–ø—Ä–∏–∫–ª–∞–¥: +380501234567)')
      return
    }

    ctx.scene.state.customerPhone = phone

    await ctx.reply(
      'üìè –û–±–µ—Ä—ñ—Ç—å —Ä–æ–∑–º—ñ—Ä:',
      Markup.inlineKeyboard([
        [Markup.button.callback('XS', 'size_xs'), Markup.button.callback('S', 'size_s')],
        [Markup.button.callback('M', 'size_m'), Markup.button.callback('L', 'size_l')],
        [Markup.button.callback('XL', 'size_xl'), Markup.button.callback('XXL', 'size_xxl')],
        [Markup.button.callback('üìñ –î–æ–≤—ñ–¥–∫–∞ –ø–æ —Ä–æ–∑–º—ñ—Ä–∞—Ö', 'size_guide')],
        [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏', 'cancel_order')]
      ])
    )

    return ctx.wizard.next()
  },

  // Step 5: Delivery method
  async(ctx) => {
    // Reset timeout on user activity
    setOrderTimeout(ctx)

    const sizes = {
      size_xs: 'XS',
      size_s: 'S',
      size_m: 'M',
      size_l: 'L',
      size_xl: 'XL',
      size_xxl: 'XXL'
    }

    if (ctx.callbackQuery?.data === 'size_guide') {
      await ctx.answerCbQuery()
      // Reset timeout on size guide view
      setOrderTimeout(ctx)
      await ctx.editMessageText(
        'üìñ –î–æ–≤—ñ–¥–∫–∞ –ø–æ —Ä–æ–∑–º—ñ—Ä–∞—Ö\n\n' +
        'XS - –æ–±—Ö–≤–∞—Ç –≥—Ä—É–¥–µ–π: 82-86 —Å–º\n' +
        'S - –æ–±—Ö–≤–∞—Ç –≥—Ä—É–¥–µ–π: 86-90 —Å–º\n' +
        'M - –æ–±—Ö–≤–∞—Ç –≥—Ä—É–¥–µ–π: 90-94 —Å–º\n' +
        'L - –æ–±—Ö–≤–∞—Ç –≥—Ä—É–¥–µ–π: 94-98 —Å–º\n' +
        'XL - –æ–±—Ö–≤–∞—Ç –≥—Ä—É–¥–µ–π: 98-102 —Å–º\n' +
        'XXL - –æ–±—Ö–≤–∞—Ç –≥—Ä—É–¥–µ–π: 102-106 —Å–º\n\n' +
        '–û–±–µ—Ä—ñ—Ç—å –≤–∞—à —Ä–æ–∑–º—ñ—Ä:',
        Markup.inlineKeyboard([
          [Markup.button.callback('XS', 'size_xs'), Markup.button.callback('S', 'size_s')],
          [Markup.button.callback('M', 'size_m'), Markup.button.callback('L', 'size_l')],
          [Markup.button.callback('XL', 'size_xl'), Markup.button.callback('XXL', 'size_xxl')],
          [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏', 'cancel_order')]
        ])
      )
      return
    }

    if (!ctx.callbackQuery || !sizes[ctx.callbackQuery.data]) {
      await ctx.reply('‚ùå –ë—É–¥—å –ª–∞—Å–∫–∞, –æ–±–µ—Ä—ñ—Ç—å —Ä–æ–∑–º—ñ—Ä –∑ –∫–Ω–æ–ø–æ–∫.')
      return
    }

    ctx.scene.state.productSize = sizes[ctx.callbackQuery.data]
    await ctx.answerCbQuery()

    await ctx.editMessageText(
      'üì¶ –î–æ—Å—Ç–∞–≤–∫–∞ —á–µ—Ä–µ–∑ –ù–æ–≤–∞ –ü–æ—à—Ç–∞\n\n–í–≤–µ–¥—ñ—Ç—å –Ω–∞–∑–≤—É –≤–∞—à–æ–≥–æ –º—ñ—Å—Ç–∞:',
      Markup.inlineKeyboard([
        [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏', 'cancel_order')]
      ])
    )

    // Set delivery method and city input mode directly
    ctx.scene.state.deliveryMethod = '–ù–æ–≤–∞ –ü–æ—à—Ç–∞'
    ctx.scene.state.waitingForCity = true

    // Skip step 6 and go directly to step 7 where city input is handled
    return ctx.wizard.selectStep(6)
  },

  // Step 6: Nova Poshta city input (delivery method is already set)
  async(ctx) => {
    // This step is now skipped by using selectStep(7)
    return ctx.wizard.next()
  },

  // Step 7: Handle Nova Poshta city search and selection
  async(ctx) => {
    if (ctx.message || ctx.callbackQuery) {
      setOrderTimeout(ctx)
    }

    // Handle change city request in step 7
    if (ctx.callbackQuery?.data === 'change_city') {
      await ctx.answerCbQuery()
      ctx.scene.state.waitingForCity = true
      ctx.scene.state.selectedCity = null
      ctx.scene.state.availableWarehouses = null
      ctx.scene.state.selectedWarehouse = null

      await ctx.editMessageText(
        'üèôÔ∏è –í–≤–µ–¥—ñ—Ç—å –Ω–∞–∑–≤—É –≤–∞—à–æ–≥–æ –º—ñ—Å—Ç–∞ –¥–ª—è –¥–æ—Å—Ç–∞–≤–∫–∏ –ù–æ–≤–∞ –ü–æ—à—Ç–∞:\n\n' +
        'üí° –ü—ñ–¥–∫–∞–∑–∫–∞: –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ —É–∫—Ä–∞—ó–Ω—Å—å–∫—É –º–æ–≤—É\n' +
        '–ù–∞–ø—Ä–∏–∫–ª–∞–¥: –ö–∏—ó–≤, –•–∞—Ä–∫—ñ–≤, –õ—å–≤—ñ–≤, –û–¥–µ—Å–∞',
        Markup.inlineKeyboard([
          [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏', 'cancel_order')]
        ])
      )
      return
    }

    // Handle city input for Nova Poshta
    if (ctx.scene.state.waitingForCity && ctx.message?.text) {
      const cityName = ctx.message.text.trim()
      await ctx.reply('üîç –®—É–∫–∞—î–º–æ –≤–∞—à–µ –º—ñ—Å—Ç–æ...')

      try {
        const cities = await novaPoshtaService.searchCities(cityName)

        if (cities.length === 0) {
          await ctx.reply(
            `‚ùå –ú—ñ—Å—Ç–æ "${cityName}" –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.\n\n` +
            'üí° –ü—ñ–¥–∫–∞–∑–∫–∞: –í–≤–µ–¥—ñ—Ç—å –Ω–∞–∑–≤—É –º—ñ—Å—Ç–∞ —É–∫—Ä–∞—ó–Ω—Å—å–∫–æ—é –º–æ–≤–æ—é.\n' +
            '–ù–∞–ø—Ä–∏–∫–ª–∞–¥: –ö–∏—ó–≤, –•–∞—Ä–∫—ñ–≤, –õ—å–≤—ñ–≤, –û–¥–µ—Å–∞\n\n' +
            '–°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑:',
            Markup.inlineKeyboard([
              [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è', 'cancel_order')]
            ])
          )
          // Stay in the same step to allow retry
          return
        }

        if (cities.length === 1) {
          // Only one city found, proceed to warehouses
          ctx.scene.state.selectedCity = cities[0]
          ctx.scene.state.waitingForCity = false

          await ctx.reply('üì¶ –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ —Å–ø–∏—Å–æ–∫ –≤—ñ–¥–¥—ñ–ª–µ–Ω—å...')
          const warehouses = await novaPoshtaService.getWarehouses(cities[0].ref)

          if (warehouses.length === 0) {
            await ctx.reply(
              '‚ùå –£ —Ü—å–æ–º—É –º—ñ—Å—Ç—ñ –Ω–µ–º–∞—î –≤—ñ–¥–¥—ñ–ª–µ–Ω—å –ù–æ–≤–∞ –ü–æ—à—Ç–∞.\n\n' +
              '–°–ø—Ä–æ–±—É–π—Ç–µ —ñ–Ω—à–µ –º—ñ—Å—Ç–æ:',
              Markup.inlineKeyboard([
                [Markup.button.callback('‚¨Ö –ó–º—ñ–Ω–∏—Ç–∏ –º—ñ—Å—Ç–æ', 'change_city')],
                [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è', 'cancel_order')]
              ])
            )
            return
          }

          ctx.scene.state.availableWarehouses = warehouses

          await ctx.reply(
            `üì¶ –û–±–µ—Ä—ñ—Ç—å –≤—ñ–¥–¥—ñ–ª–µ–Ω–Ω—è –ù–æ–≤–∞ –ü–æ—à—Ç–∞ —É –º—ñ—Å—Ç—ñ ${cities[0].name}:`,
            novaPoshtaService.formatWarehousesForKeyboard(warehouses)
          )

          return ctx.wizard.next()
        } else {
          // Multiple cities found, show selection
          ctx.scene.state.availableCities = cities

          await ctx.reply(
            'üèôÔ∏è –ó–Ω–∞–π–¥–µ–Ω–æ –∫—ñ–ª—å–∫–∞ –º—ñ—Å—Ç –∑ —Ç–∞–∫–æ—é –Ω–∞–∑–≤–æ—é. –û–±–µ—Ä—ñ—Ç—å –ø–æ—Ç—Ä—ñ–±–Ω–µ:',
            novaPoshtaService.formatCitiesForKeyboard(cities)
          )
          return
        }
      } catch (error) {
        console.error('Nova Poshta search error:', error)
        await ctx.reply(
          '‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –ø–æ—à—É–∫—É –º—ñ—Å—Ç–∞. –ú–æ–∂–ª–∏–≤—ñ –ø—Ä–∏—á–∏–Ω–∏:\n\n' +
          '‚Ä¢ –ü—Ä–æ–±–ª–µ–º–∏ –∑ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è–º –¥–æ –ù–æ–≤–æ—ó –ü–æ—à—Ç–∏\n' +
          '‚Ä¢ –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ –≤–≤–µ–¥–µ–Ω–∞ –Ω–∞–∑–≤–∞ –º—ñ—Å—Ç–∞\n\n' +
          '–°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑ –∞–±–æ –∑–≤–µ—Ä–Ω—ñ—Ç—å—Å—è –¥–æ –ø—ñ–¥—Ç—Ä–∏–º–∫–∏.',
          Markup.inlineKeyboard([
            [Markup.button.callback('üîÑ –°–ø—Ä–æ–±—É–≤–∞—Ç–∏ —â–µ —Ä–∞–∑', 'retry_city')],
            [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è', 'cancel_order')]
          ])
        )
        return
      }
    }

    // Handle city selection from multiple options
    if (ctx.callbackQuery?.data?.startsWith('city_')) {
      const cityRef = ctx.callbackQuery.data.replace('city_', '')
      const selectedCity = ctx.scene.state.availableCities?.find(city => city.ref === cityRef)

      if (!selectedCity) {
        await ctx.answerCbQuery('‚ùå –ü–æ–º–∏–ª–∫–∞ –≤–∏–±–æ—Ä—É –º—ñ—Å—Ç–∞')
        return
      }

      ctx.scene.state.selectedCity = selectedCity
      ctx.scene.state.waitingForCity = false
      await ctx.answerCbQuery()

      await ctx.editMessageText('üì¶ –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ —Å–ø–∏—Å–æ–∫ –≤—ñ–¥–¥—ñ–ª–µ–Ω—å...')

      try {
        const warehouses = await novaPoshtaService.getWarehouses(selectedCity.ref)

        if (warehouses.length === 0) {
          await ctx.editMessageText(
            '‚ùå –£ —Ü—å–æ–º—É –º—ñ—Å—Ç—ñ –Ω–µ–º–∞—î –≤—ñ–¥–¥—ñ–ª–µ–Ω—å –ù–æ–≤–∞ –ü–æ—à—Ç–∞.\n\n' +
            '–°–ø—Ä–æ–±—É–π—Ç–µ —ñ–Ω—à–µ –º—ñ—Å—Ç–æ:',
            Markup.inlineKeyboard([
              [Markup.button.callback('‚¨Ö –ó–º—ñ–Ω–∏—Ç–∏ –º—ñ—Å—Ç–æ', 'change_city')],
              [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è', 'cancel_order')]
            ])
          )
          return
        }

        ctx.scene.state.availableWarehouses = warehouses

        await ctx.editMessageText(
          `üì¶ –û–±–µ—Ä—ñ—Ç—å –≤—ñ–¥–¥—ñ–ª–µ–Ω–Ω—è –ù–æ–≤–∞ –ü–æ—à—Ç–∞ —É –º—ñ—Å—Ç—ñ ${selectedCity.name}:`,
          novaPoshtaService.formatWarehousesForKeyboard(warehouses)
        )

        return ctx.wizard.next()
      } catch (error) {
        console.error('Nova Poshta warehouses error:', error)
        await ctx.editMessageText(
          '‚ùå –ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –≤—ñ–¥–¥—ñ–ª–µ–Ω—å.\n\n' +
          '–°–ø—Ä–æ–±—É–π—Ç–µ –æ–±—Ä–∞—Ç–∏ —ñ–Ω—à–µ –º—ñ—Å—Ç–æ –∞–±–æ –∑–≤–µ—Ä–Ω—ñ—Ç—å—Å—è –¥–æ –ø—ñ–¥—Ç—Ä–∏–º–∫–∏.',
          Markup.inlineKeyboard([
            [Markup.button.callback('‚¨Ö –ó–º—ñ–Ω–∏—Ç–∏ –º—ñ—Å—Ç–æ', 'change_city')],
            [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è', 'cancel_order')]
          ])
        )
        return
      }
    }

    // Handle unexpected input or stuck state
    if (!ctx.callbackQuery && !ctx.scene.state.waitingForCity) {
      await ctx.reply(
        '‚ö†Ô∏è –©–æ—Å—å –ø—ñ—à–ª–æ –Ω–µ —Ç–∞–∫. –ë—É–¥—å –ª–∞—Å–∫–∞, –≤–≤–µ–¥—ñ—Ç—å –Ω–∞–∑–≤—É –≤–∞—à–æ–≥–æ –º—ñ—Å—Ç–∞ –¥–ª—è –¥–æ—Å—Ç–∞–≤–∫–∏:',
        Markup.inlineKeyboard([
          [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è', 'cancel_order')]
        ])
      )
      ctx.scene.state.waitingForCity = true
      return
    }

    // If still waiting for city but no valid input
    if (ctx.scene.state.waitingForCity) {
      await ctx.reply(
        '‚ùå –ë—É–¥—å –ª–∞—Å–∫–∞, –≤–≤–µ–¥—ñ—Ç—å –Ω–∞–∑–≤—É –º—ñ—Å—Ç–∞ —Ç–µ–∫—Å—Ç–æ–º.\n' +
        '–ù–∞–ø—Ä–∏–∫–ª–∞–¥: –ö–∏—ó–≤, –•–∞—Ä–∫—ñ–≤, –õ—å–≤—ñ–≤',
        Markup.inlineKeyboard([
          [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è', 'cancel_order')]
        ])
      )
    }
  },

  // Step 8: Handle warehouse selection and payment method
  async(ctx) => {
    // Reset timeout on user activity
    if (ctx.callbackQuery || ctx.message) {
      setOrderTimeout(ctx)
    }

    // Handle change city request
    if (ctx.callbackQuery?.data === 'change_city') {
      await ctx.answerCbQuery()
      ctx.scene.state.waitingForCity = true
      ctx.scene.state.selectedCity = null
      ctx.scene.state.availableWarehouses = null
      ctx.scene.state.selectedWarehouse = null

      await ctx.editMessageText(
        'üèôÔ∏è –í–≤–µ–¥—ñ—Ç—å –Ω–∞–∑–≤—É –≤–∞—à–æ–≥–æ –º—ñ—Å—Ç–∞ –¥–ª—è –¥–æ—Å—Ç–∞–≤–∫–∏ –ù–æ–≤–∞ –ü–æ—à—Ç–∞:\n\n' +
        'üí° –ü—ñ–¥–∫–∞–∑–∫–∞: –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ —É–∫—Ä–∞—ó–Ω—Å—å–∫—É –º–æ–≤—É\n' +
        '–ù–∞–ø—Ä–∏–∫–ª–∞–¥: –ö–∏—ó–≤, –•–∞—Ä–∫—ñ–≤, –õ—å–≤—ñ–≤, –û–¥–µ—Å–∞',
        Markup.inlineKeyboard([
          [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏', 'cancel_order')]
        ])
      )

      return ctx.wizard.selectStep(6) // Go back to step 7 (city selection)
    }

    // Handle warehouse selection for Nova Poshta
    if (ctx.callbackQuery?.data?.startsWith('warehouse_')) {
      const warehouseRef = ctx.callbackQuery.data.replace('warehouse_', '')
      const selectedWarehouse = ctx.scene.state.availableWarehouses?.find(wh => wh.ref === warehouseRef)

      if (!selectedWarehouse) {
        await ctx.answerCbQuery('‚ùå –ü–æ–º–∏–ª–∫–∞ –≤–∏–±–æ—Ä—É –≤—ñ–¥–¥—ñ–ª–µ–Ω–Ω—è')
        return
      }

      ctx.scene.state.selectedWarehouse = selectedWarehouse
      await ctx.answerCbQuery()

      await ctx.editMessageText(
        'üí≥ –û–±–µ—Ä—ñ—Ç—å —Å–ø–æ—Å—ñ–± –æ–ø–ª–∞—Ç–∏:',
        Markup.inlineKeyboard([
          [Markup.button.callback('üí≥ –ü–µ—Ä–µ–¥–æ–ø–ª–∞—Ç–∞ –Ω–∞ –∫–∞—Ä—Ç—É', 'payment_prepaid')],
          [Markup.button.callback('üí∞ –ù–∞–∫–ª–∞–¥–µ–Ω–∏–π –ø–ª–∞—Ç—ñ–∂', 'payment_cod')],
          [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏', 'cancel_order')]
        ])
      )

      return ctx.wizard.next()
    }

    // Only show this message if we don't have a list of warehouses available
    // This prevents the message from appearing when coming back from city selection
    if (!ctx.scene.state.availableWarehouses && !ctx.message) {
      await ctx.reply(
        '‚ö†Ô∏è –ë—É–¥—å –ª–∞—Å–∫–∞, –æ–±–µ—Ä—ñ—Ç—å –≤—ñ–¥–¥—ñ–ª–µ–Ω–Ω—è –ù–æ–≤–∞ –ü–æ—à—Ç–∞ –∑—ñ —Å–ø–∏—Å–∫—É –≤–∏—â–µ.',
        Markup.inlineKeyboard([
          [Markup.button.callback('‚¨Ö –ó–º—ñ–Ω–∏—Ç–∏ –º—ñ—Å—Ç–æ', 'change_city')],
          [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è', 'cancel_order')]
        ])
      )
    }
  },

  // Step 9: Order confirmation
  async(ctx) => {
    // Reset timeout on user activity
    if (ctx.callbackQuery) {
      setOrderTimeout(ctx)
    }

    const paymentMethods = {
      payment_prepaid: '–ü–µ—Ä–µ–¥–æ–ø–ª–∞—Ç–∞ –Ω–∞ –∫–∞—Ä—Ç—É',
      payment_cod: '–ù–∞–∫–ª–∞–¥–µ–Ω–∏–π –ø–ª–∞—Ç—ñ–∂'
    }

    if (!ctx.callbackQuery || !paymentMethods[ctx.callbackQuery.data]) {
      await ctx.reply('‚ùå –ë—É–¥—å –ª–∞—Å–∫–∞, –æ–±–µ—Ä—ñ—Ç—å —Å–ø–æ—Å—ñ–± –æ–ø–ª–∞—Ç–∏ –∑ –∫–Ω–æ–ø–æ–∫.')
      return
    }

    ctx.scene.state.paymentMethod = paymentMethods[ctx.callbackQuery.data]
    await ctx.answerCbQuery()

    const { product, customerFirstName, customerLastName, customerPhone, productSize, deliveryMethod, paymentMethod } = ctx.scene.state
    const totalAmount = product.sale_price || product.price

    // Build delivery info for Nova Poshta
    let deliveryInfo = ''
    if (ctx.scene.state.selectedCity && ctx.scene.state.selectedWarehouse) {
      deliveryInfo = `üöö –î–æ—Å—Ç–∞–≤–∫–∞: ${deliveryMethod}\n` +
        `üèôÔ∏è –ú—ñ—Å—Ç–æ: ${ctx.scene.state.selectedCity.name} (${ctx.scene.state.selectedCity.area})\n` +
        `üì¶ –í—ñ–¥–¥—ñ–ª–µ–Ω–Ω—è: ‚Ññ${ctx.scene.state.selectedWarehouse.number} - ${ctx.scene.state.selectedWarehouse.description.substring(0, 50)}...\n`
    }

    const orderSummary = 'üìã –ü—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è\n\n' +
      `üë§ –Ü–º'—è: ${customerFirstName}\n` +
      `üë§ –ü—Ä—ñ–∑–≤–∏—â–µ: ${customerLastName}\n` +
      `üì± –¢–µ–ª–µ—Ñ–æ–Ω: ${customerPhone}\n` +
      `üì¶ –¢–æ–≤–∞—Ä: ${product.name}\n` +
      `üìè –†–æ–∑–º—ñ—Ä: ${productSize}\n` +
      `üí∞ –¶—ñ–Ω–∞: ${totalAmount}‚Ç¥\n` +
      deliveryInfo +
      `üí≥ –û–ø–ª–∞—Ç–∞: ${paymentMethod}\n\n` +
      '‚úÖ –ü—ñ–¥—Ç–≤–µ—Ä–¥–∏—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è?'

    await ctx.editMessageText(
      orderSummary,
      Markup.inlineKeyboard([
        [Markup.button.callback('‚úÖ –ü—ñ–¥—Ç–≤–µ—Ä–¥–∏—Ç–∏', 'confirm_order')],
        [Markup.button.callback('‚úèÔ∏è –†–µ–¥–∞–≥—É–≤–∞—Ç–∏', 'edit_order')],
        [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏', 'cancel_order')]
      ])
    )

    return ctx.wizard.next()
  },

  // Step 10: Submit to CRM
  async(ctx) => {
    if (!ctx.callbackQuery) return

    await ctx.answerCbQuery()

    if (ctx.callbackQuery.data === 'edit_order') {
      setOrderTimeout(ctx) // Reset timeout when editing
      return ctx.wizard.selectStep(0) // Start over
    }

    if (ctx.callbackQuery.data === 'cancel_order') {
      clearAllTimeouts(ctx)
      await ctx.editMessageText('‚ùå –ó–∞–º–æ–≤–ª–µ–Ω–Ω—è —Å–∫–∞—Å–æ–≤–∞–Ω–æ.')
      return ctx.scene.leave()
    }

    if (ctx.callbackQuery.data === 'confirm_order') {
      // Clear timeout when confirming order
      clearAllTimeouts(ctx)
      await ctx.editMessageText('‚è≥ –û–±—Ä–æ–±–ª—è—î–º–æ –≤–∞—à–µ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è...')

      try {
        const { product, customerName, customerFirstName, customerLastName, customerPhone, deliveryMethod, paymentMethod } = ctx.scene.state

        // Get user ID (fallback if ctx.user is not set)
        let userId = ctx.user?.id
        if (!userId) {
          const user = await db.get('SELECT id FROM users WHERE telegram_id = ?', [ctx.from.id])
          userId = user?.id
        }

        if (!userId) {
          throw new Error('User not found in database')
        }

        // Generate order number
        const orderPrefix = 'VID'
        const orderNumber = `${orderPrefix}${Date.now()}`

        // Build delivery address and Nova Poshta data (Nova Poshta only)
        let deliveryAddress = ''
        let novaPoshta = {}

        if (ctx.scene.state.selectedCity && ctx.scene.state.selectedWarehouse) {
          // Prepare Nova Poshta data for CRM
          novaPoshta = novaPoshtaService.prepareForCRM(ctx.scene.state.selectedCity, ctx.scene.state.selectedWarehouse)
          deliveryAddress = `${ctx.scene.state.selectedCity.name}, –≤—ñ–¥–¥—ñ–ª–µ–Ω–Ω—è ‚Ññ${ctx.scene.state.selectedWarehouse.number}`
        }

        // Save order to database
        const orderResult = await db.run(`
          INSERT INTO orders (
            order_number, user_id, status, total_amount, customer_name, customer_phone, 
            delivery_method, delivery_address, payment_method, notes
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `, [
          orderNumber, userId, 'pending', product.sale_price || product.price,
          customerName, customerPhone, deliveryMethod, deliveryAddress, paymentMethod,
          `Telegram: @${ctx.from.username || ctx.from.first_name}. –†–æ–∑–º—ñ—Ä: ${ctx.scene.state.productSize}`
        ])

        const orderId = orderResult.id

        // Save order items
        await db.run(`
          INSERT INTO order_items (order_id, product_id, product_name, product_price, quantity, size)
          VALUES (?, ?, ?, ?, ?, ?)
        `, [orderId, product.id, product.name, product.sale_price || product.price, 1, ctx.scene.state.productSize])

        // Submit to CRM with Nova Poshta data
        const crmResult = await crmService.createOrder({
          telegramOrderId: orderId,
          products: [{
            id: product.id,
            name: product.name,
            price: product.sale_price || product.price,
            quantity: 1,
            description: product.description
          }],
          customerName,
          customerFirstName,
          customerLastName,
          customerPhone,
          telegramUsername: ctx.from.username,
          deliveryMethod,
          deliveryAddress,
          paymentMethod,
          novaPoshta, // Include Nova Poshta parameters
          notes: `–ó–∞–º–æ–≤–ª–µ–Ω–Ω—è #${orderId} –∑ Telegram –±–æ—Ç–∞. –†–æ–∑–º—ñ—Ä: ${ctx.scene.state.productSize}`
        })

        if (crmResult.success) {
          // Update order with CRM ID
          await db.run('UPDATE orders SET crm_order_id = ? WHERE id = ?', [crmResult.orderId, orderId])

          // Clear timeout on successful order
          clearAllTimeouts(ctx)

          await ctx.editMessageText(
            '‚úÖ –ó–∞–º–æ–≤–ª–µ–Ω–Ω—è —É—Å–ø—ñ—à–Ω–æ –æ—Ñ–æ—Ä–º–ª–µ–Ω–æ!\n\n' +
            `üìã –ù–æ–º–µ—Ä –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è: ${orderNumber}\n` +
            'üì± –ù–∞—à –º–µ–Ω–µ–¥–∂–µ—Ä –∑–≤\'—è–∂–µ—Ç—å—Å—è –∑ –≤–∞–º–∏ –Ω–∞–π–±–ª–∏–∂—á–∏–º —á–∞—Å–æ–º.\n\n' +
            '–î—è–∫—É—î–º–æ –∑–∞ –ø–æ–∫—É–ø–∫—É! üôè',
            Markup.inlineKeyboard([
              [Markup.button.callback('üè† –ì–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é', 'main_menu')]
            ])
          )
        } else {
          throw new Error(crmResult.error)
        }
      } catch (error) {
        console.error('Order submission error:', error)
        // Clear timeout on error
        clearAllTimeouts(ctx)

        await ctx.editMessageText(
          '‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ—Ñ–æ—Ä–º–ª–µ–Ω–Ω—ñ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è.\n\n' +
          '–í–∞—à—ñ –¥–∞–Ω—ñ –∑–±–µ—Ä–µ–∂–µ–Ω–æ, –º–∏ –∑–≤\'—è–∂–µ–º–æ—Å—è –∑ –≤–∞–º–∏ –≤—Ä—É—á–Ω—É.\n\n' +
          '–í–∏–±–∞—á—Ç–µ –∑–∞ –Ω–µ–∑—Ä—É—á–Ω–æ—Å—Ç—ñ.',
          Markup.inlineKeyboard([
            [Markup.button.callback('üè† –ì–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é', 'main_menu')]
          ])
        )
      }

      return ctx.scene.leave()
    }
  }
)

// Handle cancel order
orderWizard.action('cancel_order', async(ctx) => {
  await ctx.answerCbQuery()
  clearAllTimeouts(ctx)
  await ctx.editMessageText('‚ùå –ó–∞–º–æ–≤–ª–µ–Ω–Ω—è —Å–∫–∞—Å–æ–≤–∞–Ω–æ.')
  return ctx.scene.leave()
})

// Handle retry city search
orderWizard.action('retry_city', async(ctx) => {
  await ctx.answerCbQuery()
  setOrderTimeout(ctx) // Reset timeout on retry
  ctx.scene.state.waitingForCity = true
  await ctx.editMessageText(
    'üèôÔ∏è –í–≤–µ–¥—ñ—Ç—å –Ω–∞–∑–≤—É –≤–∞—à–æ–≥–æ –º—ñ—Å—Ç–∞ –¥–ª—è –¥–æ—Å—Ç–∞–≤–∫–∏ –ù–æ–≤–∞ –ü–æ—à—Ç–∞:\n\n' +
    'üí° –ü—ñ–¥–∫–∞–∑–∫–∞: –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ —É–∫—Ä–∞—ó–Ω—Å—å–∫—É –º–æ–≤—É\n' +
    '–ù–∞–ø—Ä–∏–∫–ª–∞–¥: –ö–∏—ó–≤, –•–∞—Ä–∫—ñ–≤, –õ—å–≤—ñ–≤, –û–¥–µ—Å–∞',
    Markup.inlineKeyboard([
      [Markup.button.callback('‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è', 'cancel_order')]
    ])
  )
})

// Clear timeout on scene leave
orderWizard.leave((ctx) => {
  clearAllTimeouts(ctx)
})

module.exports = orderWizard
